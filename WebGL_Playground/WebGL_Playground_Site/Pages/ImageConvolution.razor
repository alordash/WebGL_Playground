@page "/ImageConvolution"

@using Blazor.Extensions.Canvas.WebGL;
@using WebGLWrapping;
@using Geometry;
@using System.Reflection.Metadata
@using System.Globalization
@inject HttpClient Http;
@inject IJSRuntime JS

<img id="GLImageLoader" crossorigin="anonymous" style="display: none">

<h3>Image Convolution</h3>

<input type="text" @bind="imagePath" @onkeyup="ImagePathKeyUp" placeholder="Path to image...">
<br/>
<select @bind="CurrentKernel">
    @foreach (var key in UsingKernels.Keys) {
        <option value="@key">@key</option>
    }
</select> 
<input type="checkbox" @bind="ShowOriginal"> Show original
<br/>
<BECanvas Width="200" Height="900" @ref="canvasReference"></BECanvas>
<br/>
<NumberInput @ref="TimeStepInput" DefaultValue="0.005"/>
<button @onclick="Interpolate">Interpolate</button>
<br/>
<input type="range" @bind="Time" min="0" max="1" step="0.01"/>
<br/>
<MatrixDisplay @ref="asdasd" Matrix="ConvolutionKernels.ArrayOfArraysToMatrix(UsingKernels.Values.ToArray()[0], 3, 3)"></MatrixDisplay>

@code {

    MatrixDisplay asdasd;

    public static readonly Dictionary<string, float[]> UsingKernels = ConvolutionKernels.MyKernels;
    private readonly float k = UsingKernels.Count - 1;
    private readonly float[] kernels = UsingKernels.Values.SelectMany(x => x).ToArray();
    
    private BECanvasComponent canvasReference;

    private WebGLContext gl;
    private GLDrawer glDrawer;

    private string imagePath = "Data/image2.jpg";

    private string currentKernel = "normal";
    public string CurrentKernel {
        get => currentKernel;
        set {
            currentKernel = value;
            var index = UsingKernels.Keys.ToList().IndexOf(currentKernel);
            time = index / k - 0.001f;
            Console.WriteLine($"index = {index}, time = {time}");
            Draw();
        }
    }

    private async Task ImagePathKeyUp(KeyboardEventArgs e) {
        if (e.Key == "Enter") {
            Draw();
        }
    }

    private bool showOriginal = false;
    public bool ShowOriginal {
        get => showOriginal;
        set {
            showOriginal = value;
            LightDraw();
        }
    }

    private async Task Draw() {
        await glDrawer.FillUniformI("u_showOriginal", showOriginal ? 1 : 0);
        await glDrawer.DrawImage(JS, DotNetObjectReference.Create(this), canvasReference, imagePath, Time);
    }

    [JSInvokable]
    public async void ImageLoaded(int width, int height) {
        canvasReference.Width = width;
        canvasReference.Height = height;
        await glDrawer.FillUniformF("u_textureSize", width, height);
        await glDrawer.FillUniformF("u_resolution", width, height);
        await gl.ViewportAsync(0, 0, width, height);
        await glDrawer.DrawBlankRectangle(GLHelper.MapTrianglesVertices(width, height));
    }

    private async Task LightDraw() {
        await glDrawer.FillUniformI("u_showOriginal", showOriginal ? 1 : 0);
        await glDrawer.SetTime(Time);
        await glDrawer.DrawBlankRectangle(Array.Empty<float>());
    }

    public NumberInput TimeStepInput;
    public float time = 0f;
    public float Time {
        get => time;
        set {
            time = value;
            LightDraw();
        }
    }
    private Task InterpolateTask;
    private bool ContinueInterpolation = true;
    private float timeStep = 0.005f;

    protected async Task Interpolate() {
        timeStep = (float)TimeStepInput.Value;
        if (InterpolateTask is not null) {
            ContinueInterpolation = !ContinueInterpolation;
            return;
        }
        InterpolateTask = Task.Run(async () => {
            var interval = (int)(3000 * timeStep);
            while (true) {
                await Task.Delay(interval);
                if (!ContinueInterpolation) {
                    continue;
                }
                await glDrawer.ClearWithColor(0f, 0f, 0f, 1f);
                var newTime = Time + timeStep;
                switch (newTime) {
                    case > 1f:
                        newTime = 0f;
                        break;
                    case < 0f:
                        timeStep = -timeStep;
                        newTime = Time + timeStep;
                        break;
                }
                Time = newTime;
                await InvokeAsync(StateHasChanged);
            }
        });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            gl = GLContext.GL = await canvasReference.CreateWebGLAsync(new WebGLContextAttributes {
                PowerPreference = WebGLContextAttributes.POWER_PREFERENCE_HIGH_PERFORMANCE
            });

            var vertShaderSource = await Misc.GetFileContents("Shaders/imageConvolution.vert", Http);
            var fragShaderSource = await Misc.GetFileContents("Shaders/imageConvolution.frag", Http);

            var glProgram = await GLProgram.SetUpProgram(vertShaderSource, fragShaderSource);
            glDrawer = new GLDrawer(glProgram);
            await gl.UseProgramAsync(glProgram);
            await glDrawer.ClearWithColor(0.5f, 0.5f, 0.5f, 1f);

            var kernels = UsingKernels.Values.SelectMany(x => x).ToArray();
            await glDrawer.FillUniformF("u_k", k);
            await glDrawer.FillUniformArrayF("u_kernels", kernels, 1);
            Console.WriteLine($"Kernels count = {kernels.Length}");
            Draw();
        }
    }

}