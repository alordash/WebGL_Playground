@page "/ImageConvolution"

@using Blazor.Extensions.Canvas.WebGL;
@using WebGLWrapping;
@using Geometry;
@using System.Reflection.Metadata
@inject HttpClient Http;
@inject IJSRuntime JS

<img id="GLImageLoader" crossorigin="anonymous" style="display: none">

<h3>Image Convolution</h3>

<input type="text" @bind="imagePath" @onkeyup="ImagePathKeyUp" placeholder="Path to image...">
<br/>
<select @bind="CurrentKernel">
    @foreach (var key in ConvolutionKernels.DefaultKernels.Keys) {
        <option value="@key">@key</option>
    }
</select>
<br/>
<BECanvas Width="200" Height="900" @ref="canvasReference"></BECanvas>
<br/>
<NumberInput @ref="TimeStepInput" DefaultValue="0.005"/>
<button @onclick="Interpolate">Interpolate</button>
@code {
    private BECanvasComponent canvasReference;

    private WebGLContext gl;
    private GLDrawer glDrawer;

    private string imagePath = "Data/image2.jpg";

    private string currentKernel = "normal";
    public string CurrentKernel {
        get => currentKernel;
        set {
            currentKernel = value;
            var index = ConvolutionKernels.DefaultKernels.Keys.ToList().IndexOf(currentKernel);
            time = index / (float)ConvolutionKernels.DefaultKernels.Count;
            Draw();
        }
    }

    private async Task ImagePathKeyUp(KeyboardEventArgs e) {
        if (e.Key == "Enter") {
            Draw();
        }
    }

    private async Task Draw() {
//        var kernel = ConvolutionKernels.DefaultKernels[currentKernel];
        await glDrawer.DrawImage(JS, DotNetObjectReference.Create(this), canvasReference, imagePath, time);
    }

    [JSInvokable]
    public async void ImageLoaded(int width, int height) {
        canvasReference.Width = width;
        canvasReference.Height = height;
        await glDrawer.FillUniformF("u_textureSize", width, height);
        await glDrawer.FillUniformF("u_resolution", width, height);
        await gl.ViewportAsync(0, 0, width, height);
        await glDrawer.DrawBlankRectangle(GLHelper.MapTrianglesVertices(width, height));
    }

    public NumberInput TimeStepInput;
    public float time = 0f;
    private Task InterpolateTask;
    private bool ContinueInterpolation = true;
    private float timeStep = 0.005f;

    protected async Task Interpolate() {
        timeStep = (float)TimeStepInput.Value;
        if (InterpolateTask is not null) {
            ContinueInterpolation = !ContinueInterpolation;
            return;
        }
        InterpolateTask = Task.Run(async () => {
            var interval = (int)(1000 * timeStep);
            while (true) {
                await Task.Delay(interval);
                if (!ContinueInterpolation) {
                    continue;
                }
                await glDrawer.ClearWithColor(0f, 0f, 0f, 1f);
                var newTime = time + timeStep;
                switch (newTime) {
                    case > 1f:
                        timeStep = -timeStep;
                        newTime = time + timeStep;
                        break;
                    case < 0f:
                        timeStep = -timeStep;
                        newTime = time + timeStep;
                        break;
                }
                time = newTime;

                await glDrawer.SetTime(time);
                await glDrawer.DrawBlankRectangle(Array.Empty<float>());
            }
        });
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            gl = GLContext.GL = await canvasReference.CreateWebGLAsync(new WebGLContextAttributes {
                PowerPreference = WebGLContextAttributes.POWER_PREFERENCE_HIGH_PERFORMANCE
            });

            var vertShaderSource = await Misc.GetFileContents("Shaders/imageConvolution.vert", Http);
            var fragShaderSource = await Misc.GetFileContents("Shaders/imageConvolution.frag", Http);

            var glProgram = await GLProgram.SetUpProgram(vertShaderSource, fragShaderSource);
            glDrawer = new GLDrawer(glProgram);
            await gl.UseProgramAsync(glProgram);
            await glDrawer.ClearWithColor(0.5f, 0.5f, 0.5f, 1f);
            
            var kernels = ConvolutionKernels.DefaultKernels.SelectMany(x => x.Value).ToArray();
            await glDrawer.FillUniformArrayF("u_kernels", kernels, 1);
            Console.WriteLine($"Kernels count = {kernels.Length}");
            Draw();
        }
    }

}